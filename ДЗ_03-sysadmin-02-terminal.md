# Домашняя работа к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.  

    __ОТВЕТ:__ Команды в Linux в общем случае бывают отдельным исполняемым файлом, или встроенной функцией командной оболочки. Команда `cd` является встроенной функцией командной оболочки.
    ```bash
    vagrant@vagrant:~$ type cd
    cd is a shell builtin
    ```
1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.  

    __ОТВЕТ:__ Опция `-c` изменяет вывод `grep` и вместо строк содержащих значение поиска выводится их количество.
    ```bash
    wizard ~ % grep -c home /etc/fstab
    9
    ```
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  

    __ОТВЕТ:__ Родителем для всех процессов в виртуальной машине Ubuntu 20.04. является процесс `/sbin/init`
    ```bash
    vagrant@vagrant:~$ ps up 1
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  0.0  0.5 101788 11328 ?        Ss   05:21   0:01 /sbin/init
    ```
1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?  

    __ОТВЕТ:__ Создадим еще одну ssh-сессию, узнаем `tty`, в первой сессии `/dev/pts/0`, во второй сессии `/dev/pts/1`. Выполним в первой сессии `ls /123 2>/dev/pts/1`:
    ```bash
    vagrant@vagrant:~$ tty
    /dev/pts/0
    vagrant@vagrant:~$ ls /123 2>/dev/pts/1
    vagrant@vagrant:~$
    ```
    и увидим вывод stderr в другой:
    ```bash
    vagrant@vagrant:~$ tty
    /dev/pts/1
    vagrant@vagrant:~$ ls: cannot access '/123': No such file or directory
    ```
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  

    __ОТВЕТ:__ Передадим в grep fstab и выведем результат в out `grep \/ 0</etc/fstab > ./out; cat ./out` хотя в данном случае писать 0< совсем необязательно:
    ```bash
    vagrant@vagrant:~$ grep \/ /etc/fstab > ./out; cat ./out
    # /etc/fstab: static file system information.
    /dev/mapper/vgvagrant-root /               ext4    errors=remount-ro 0       1
    # /boot/efi was on /dev/sda1 during installation
    UUID=5A33-EBB5  /boot/efi       vfat    umask=0077      0       1
    /dev/mapper/vgvagrant-swap_1 none            swap    sw              0       0
    /vagrant /vagrant vboxsf uid=1000,gid=1000,nofail 0 0
    ```
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  

    __ОТВЕТ:__ Находясь в графическом режиме клавишами `Ctrl`+`Alt`+`F2`перейдем в терминал `/dev/tty2`, вернемся в графический режим `Ctrl`+`Alt`+`F1` и там выполним `echo from pts5 > /dev/tty2`, переключимся в терминал и увидим `from pts5`

1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?  

    __ОТВЕТ:__ В результате выполнения команды `bash 5>&1` создастся новый экземпляр командной оболочки у которого кроме стандартных файловых дескрипторов 0, 1 и 2 будет присутствовать FD 5 указывающий на stdout. Если после этого выполнить в этом экземпляре bash `echo netology > /proc/$$/fd/5`, то получим `netology` на стандартный вывод т.к. отправляли мы слово на FD 5 нашего текущего процесса (а это bash с дополнительным FD) а он указывает на stdout, вот в stdout слово `netology` и вывалится.
    
1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.  

    __ОТВЕТ:__ Это можно осуществить с помощью `command1 3>&2 2>&1 1>&3 | command2`
    
1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?  

    __ОТВЕТ:__ Команда `cat /proc/$$/environ` выведет список локальных переменных текущего сеанса с их значениями. Аналогичный по содержанию вывод можно получить командой `env -0`
    
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.  

    __ОТВЕТ:__
    ```bash
    wizard ~ % cat /proc/cpuinfo|grep -o "sse[0-9_]*"|sort -u|tail -1
    sse4_2
    ```
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```
	Почитайте, почему так происходит, и как изменить поведение.  

    __ОТВЕТ:__ В данном случае ssh имеет следующий синтаксис `ssh destination [command]`, если `command` определена, то она выполняется на удаленном хосте (`destination`) вне терминала. Чтобы исправить это необходимо использовать ключ `-t`, который вызывает принудительное выделение псевдотерминала.
    ```bash
    vagrant@vagrant:~$ ssh -t localhost 'tty'
    vagrant@localhost's password:
    /dev/pts/1
    Connection to localhost closed.
    ```
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
